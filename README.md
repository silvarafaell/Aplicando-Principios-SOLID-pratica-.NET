#Curso C# - Aplicando Princípios SOLID na prática na Udemy 

### Fundamentos da programação Orientada a Objetos
- O paradigma da programação orientada a objetos
  - A programação orientada a objetos é uma abordagem de projeto em que pensamos em termos de objetos do mundo real, em vez de funções ou métodos.
  - Na POO os programas são organizados em torno de objetos e dados, em de ações e procedimentos.
  - O objetivo do paradigma da programação orientada a objetos é refletir na estrutura do software a vida real do problema que o software busca resolver.
  - Os princípios básicos da POO
    - Encapsulamneto -Permite ocultar a implementação de uma classe do mundo externo
    - Herança - Permite herdar atributos e comportamentos de uma classe
    - Polimorfismo - Permite que um objeto se comporte de formas diferentes
    - Abstração - É o processo de identificação dos objetos e seus relacionamentos.
- Classes e Objetos
  - uma classe é um modelo ou template para criar objetos e contem os atributos e comportamentos que definem os objetos.
  - Os objetos não existem sem a classe.
- Construtor
  - Um construtor é um método especial usado para inicializar objetos
  - É chamado quando um objeto de uma classe é criado usando a palavra-chave new
  - pode ser usado para definir valores iniciais para os atributos de um objeto.
- A palavra this
  - Refere-se a instancia atual da classe
  - É usada como um modificador do primeiro parâmetro de um método de extensão.
- Modificadores de Acesso
  - É usado para definir o nível de acesso/a visibilidade para classes, campos, métodos e propriedades.
  - public
    - Não existe restrição de acesso
  - private
    - Acesso limitado a membros da mesma classe(Padrão)
  - protected
    - Acesso limitado a membros da mesma classe e das classes que herdeiras
  - internal
    - Acesso limitado a classes definidas dentro do assembly do projeto atual
  - protected internal
    - Acesso limitado ao assembly atual e aos tipos derivados da classe que o contem.
  - private protected
    - O acesso é limitado a classe que o contem ou a tipos derivados da classe que o contem no assembly atual
- Propriedades e Encapsulamento
  - o que é encapsulamento ?
    - É o processo de ocultar ou esconder os membros de uma classe do acesso exterior usando modificadores de acesso.
    - É conhecido como ocultação de informação ou information hiding.
    - Beneficios ?
      - Fornece uma maneira de preservar a integridade do estado dos dados.
- Encapsulamento e Modelo de Domínio
  - Encapsular é ocultar os detalhes da implementação de um objeto de forma manter o seu estado consistente.
  - O modelo de domínio é uma representação de classes conceituais a partir do mundo real
  - Modelo de domínio anêmico
    - É um modelo sem logica, definido apenas com propriedades com get e set públicos
    - Desvantagens
      - Violação do encapsulamento
      - Dificuldade na manutenção
      - Logica de negócios duplicada
      - Estado inconsistente
      - Baixa coesão
  - Modelo de domínio rico(usamos o encapsulamento para evitar que valores inválidos sejam atribuídos as propriedades do domínio)
- Métodos e Sobrecarga de métodos
  - Um método é um bloco de código que contem uma série de instruções.
  - Um programa faz com que as instruções sejam executadas chamando o método e especificando os argumentos de método necessários.
  - O método Main é o ponto de entrada para cada aplicação C# e é chamado pelo o runtime do Commom Language Runtime(CLR)
  - Assinatura do método
    - Permite identificar um método de forma única
    - Nivel de acesso
    - Nome do método
    - Número e Tipo de Parâmetros
  - Sobrecarga acontece quando temos métodos com mesmos nomes mas com assinatura diferentes.
- Métodos: Parâmetros Opcionais
  -  Na linguagem C# os métodos podem conter parâmetros obrigatórios e também parâmetros opcionais.
  -  Devem possuir um valor padrão constante. 
- Métodos: Argumentos Nomeados
  - Por padrão a chamada de um método requer que passemos os argumentos respeitando o posicionamento dos parâmetros na lista de parâmetros definidos no método.
- Métodos Estáticos
  - Uma classe é um modelo ou gabarito para definição de objetos.
  - Um objeto não existe sem a definição de uma classe.
  - Criar um objeto de uma classe significa criar uma instancia da classe.
  - A linguagem C# palavra-chave static pode ser aplicada a classes, variáveis, métodos, eventos, construtores
  - O modificador static torna um item não instanciável
  - Se o modificador static for aplicado a uma variável, método ou propriedade da classe, eles poderão ser acessados sem a criação de um objeto da classe.
  - Membros declarados como static são membros da classe e não membros de instancia
  - Podemos acessar membros declarados como static em uma classe sem criar uma instancia da classe.
  - Use métodos e membros estáticos com ponderação
- Métodos de Extensão
  - Permitem que voce adicione uma nova funcionalidade a um tipo existente sem ter que criar um novo tipo derivado, dessa forma a funcionalidade se comporta como um outro membro do tipo.
  - Podemos criar um novo método em um tipo que pode ser chamado como se ele fosse um método de instancia deste tipo
  - Essa é uma forma de aplicar o princípio aberto/fechado(OCP) que diz, voce deve ser capaz de estender um comportamento de uma classe, sem modificá-la.
  - São definidos como estáticos, mas são chamados usando a sintaxe do método de instancia.
  - Seu primeiro parâmetro especifica em que tipo o método opera e o parâmetro é precedido pelo o modificador this.
- Nomenclatura
  - Um identificador é o nome que voce atribui a classes, métodos, interfaces, structs,delegates,enumerações, membros de classe, variáveis e namespaces.
  - Os identificadores devem começar com uma letra ou sublinhado
  - Os números são permitidos nos identificadores apenas apos o primeiro caractere.
  - Classes, métodos, construtores, propriedades, tipos e namespaces.
    - Usar **PascalCasing**: Coloca em maiúsculo o primeiro caractere de cada palavra.
    - ex: TaxaAmortizacao, CalculoImpostoPessoaFisica
  - Parâmetros e variáveis locais
    - Usar **CamelCasing**: Coloca em maiúscula o primeiro caractere de cada palavra, exceto da primeira palavra.
    - ex: valorTotal, dataPedidoIsentoImpostoICMS
  - Nomenclatura - Convenções
    - Escolha nome de identificadores legíveis
    - Favoreça a legibilidade a brevidade
    - Não use abreviações ou contrações como parte dos nomes de identificador
      - Errado: valSalSem, descImp, NumDepen, Calcdesc
      - Correto: valorSalarioSemanal, descontoImposto, NumeroDependentes, CalcularDesconto
  - Modelo de domínio Anêmico(Anemic Domain Model)
    - É um modelo de domínio em que os objetos de domínio contem pouca ou nenhuma logica negócios(validações, cálculos, regras de negócios e etc) sendo representados apenas         como uma estrutura de dados sem comportamento.
    - É considerado um anti-pattern ou anti-padrão devido a uma completa falta de princípios aderentes a orientações a objetos, visto que eles são objetos burros que                dependem do código de chamada para validação e outras lógicas de negócios.
    - Como consequência, isso pode levar a repetição de código, a uma integridade de dados ruim e a uma maior complexidade que deve ser definida nas camadas superiores.
    - Martin Fowler Anti pattern
    - Exemplo de modelo de domínio anêmico
      - Somente dados
      - Sem comportamentos
      - Sem validações
      - Sem logica
      - Sem regras de negocio nem cálculos
    - O modelo anêmico despeita os conceitos do paradigma da POO - Programação orientada a objetos
    - Os objetos no paradigma possuem dados e comportamento, e, o objeto deve modelar a entidade
    - Ao separar o comportamento, não estamos seguindo o paradigma da POO, com comportamentos residindo em uma classe separada, será difícil herdar, aplicar polimorfismo,          abstração e assim por diante.
    - Além disso modelos anêmicos podem ter estados inconsistentes a qualquer momento.
    - Opções justificáveis para usar modelo anêmico seria usar para DTOs - Data Transfer Objects, e fazer um CRUD(Create, Read,Update e Delete) Basico.
 - Herança: Conceitos básicos
   - O que é herança ?
     - Na linguagem C#, é possível herdar membros (campos, propriedades e métodos) de uma classe para outra
     - Herança é a capacidade de criar uma classe base com membros(campos, propriedades e métodos) que podem ser usados em classes derivadas da classe base
     - Classe derivada(filha ou subclasse - a classe que herda de outra classe;
     - Classe base (pai ou superclasse) - a classe que está sendo herdada;
     - Um dos principais benefícios da herança é o reaproveitamento de código.
- Herança: Comportamentos e considerações
  - Todos os membros públicos(campos, propriedades, métodos) são herdados. (membros privados não são herdados).
  -  O modificador de acesso protected torna um membro de uma classe base somente acessível as suas classes derivadas.
  -  Toda a classe herda de Object(ela é a classe pai de todas as classes).
- Herança: Construtores
  - O Construtor da classe base sempre será executado primeiro durante a instanciação da classe filha.
  - O Construtor da classe base não é herdado pela classe filha e por isso precisa ter seu proprio construtor definido.
- Herança: DownCasting e UpCasting
  - Herança: UpCasting
    - A operação de UpCasting converte um objeto de um tipo especializado (Classe filha) para um tipo mais geral (classe base)
  - Herança: DownCasting
    - A operação de DownCasting converte um objeto de um tipo geral(classe base) para um tipo mais especializado(classe filha)
- Os Operadores: is e as
  - O operador as é usado para executar a conversão entre tipos de referencia compatíveis
  - Retorna o objeto quando eles são compatíveis com o tipo especificado ou retorna null se a conversão não for possível em vez de gerar uma exceção
  - O operador is é usado para verificar se o tipo de um objeto é compatível com o tipo especificado ou não

### UML, Herança, Interface e Polimorfismo
- Diagrama de Classes
  - UML - Unified Modeling Language
  - A UML é uma linguagem de modelagem designada para especificar, visualizar, construir e documentar um sistema.
  - Na UML a representação de uma classe usa um retângulo dividido em três partes:
    - Nome da classe
    - Atributos da classe
    - Métodos da classe
- UML - Herança
  - A herança é um tipo de relacionamento "é um" ou "is a" entre uma classe base e uma ou mais classes derivadas, em que as classes derivadas são versões especializadas da      classe base
- UML - Composição
  - Um relacionamento de composição ocorre quando um objeto de uma classe é composto de um ou mais objetos de outra classe.
  - A composição é um relacionamento do tipo: "Tem um"
- UML - Agregação
  - Um relacionamento de agregação é um tipo especial de composição onde objetos de uma classe podem conter um ou mais objetos de outra classe.
  - A agregação é representada por uma seta com um triangulo(diamante) vazio.
  - A agregação é um relacionamento do tipo: "Tem um"
  - A parte e o todo são independentes
  - A parte pode existir sem o todo
- Acoplamento: Conceito
  - Acoplamento
    - É a medida de quão interconectados estão os componentes de um sistema.
    - É o nível de dependência e de conhecimento que pode existir entre os componentes de um sistema.
    - Existem dois tipos de acoplamento:
      - Acoplamento forte
      - Acoplamento fraco
    - Acoplamento forte
      - No acoplamento forte os componentes são interconectados de uma forma tão dependente que é praticamente impossível alterar um deles sem causar efeitos colaterais em           todo ou em grande parte do sistema
      - No acoplamento forte as classes e os objetos são dependentes um do outro, portanto, reduzem a reutilização do código.
      - Uma classe com acoplamento forte depende de muitas classes para fazer o seu serviço.
    - Acoplamento fraco
      - No acoplamento fraco os componentes de um sistema são interconectados de modo que um dependa do outro o mínimo possível
      - Uma classe com acoplamento fraco não é dependente de muitas classes para fazer o que ele tem que fazer.
      - Uma classe com acoplamento fraco é mais fácil de manter, de entender e de ser reusada.
      - Vantagens do acoplamento fraco
        - O acoplamento fraco é preferido ao forte, uma vez que alterar uma classe não afetará outra.
        - Reduz dependências em uma classe e isso facilita a reutilização de código.
        - Um modulo não quebra outros módulos
        - Melhora a testabilidade do sistema
        - O código é mais fácil de manter
    - Classes Abstratas
      - Uma classe abstrata é um tipo especial de classe que não pode ser instanciada ou seja voce não pode criar um objeto a partir de uma classe abstrata.
      - É definida usando o modificador abstract e pode conter métodos comuns e métodos abstratos que também são definidos pelo o modificador abstract.
      - Um método abstrato é um método que não possui implementação na classe abstrata.
      - Um método abstrato possui somente a definição de sua assinatura
      - A sua implementação deve ser feita na classe derivada
    - O modificador sealed
      - Uma classe selada utiliza o modificador sealed e impede que outras classes herdem deste classe.(não pode atuar como uma classe base)
      - São usadas para restringir o recurso de herança
      - Elas podem ser consideradas o oposto das classes abstratas
      - Podem ser instanciadas e usadas normalmente.
    - Interfaces
      - Uma interface é um tipo de classes que **contem apenas as assinaturas de métodos, propriedades, eventos e indexadores**, e todos os membros de uma interface     são          **públicos e abstratos.**
      - Uma interface funciona como **um contrato** entre si e qualquer classe que a implementa.
      - Uma classe que herda uma interface é obrigada a implementar todos os seus membros.
      - Assim, uma interface **não contem uma implementação**, contem apenas definições dee métodos, propriedades, eventos e indexadores que expõe funcionalidades que **uma         classe que quiser usar** terá que implementar.
      - Interface
        - Não contem implementação
        - Não contem membros privados
        - Os membros são todos públicos ou abstratos
        - Não pode ser instanciada
        - Não contem um construtor
        - **As classes que herdam a interface devem implementar os métodos.**
        - Uma classe pode implementar mais de uma interface.
      - Interface: Vantagens
        - Da mesma maneira que podemos fazer referencia a um objeto usando uma variável de classe, podemos definir um objeto usando uma variável de interface
        - Um dos pilares da programação orientada a objetos diz: "Programe para uma interface e não para uma implementação".(Erick Gomma)
        - Usar interface é uma forma de criar e definir um contrato que ajuda na organização do código.
        - Permitem criar sistemas fracamente acoplados e mais flexível e mais flexível a mudanças( ou resiliente a mudanças)
        - Programar para interface deixa o código mais flexível, permitindo trocar a implementação de um componente em tempo de execução.
        - O código gerado é mais limpo e fácil de manter e entender pois existem uma separação de responsabilidade entre os componentes do sistema.
      - Interfaces: Desacoplando o código: Conceito
        - Usar interfaces para desacoplar o código (baixo acoplamento)
        - tornar o código mais fácil para testar
        - Tornar o código mais fácil de manter
        - Tornar o código mais fácil de estender
        - Programe para interface e não para uma implementação
      - Classes Abstratas versus Interfaces
        - Classes Abstratas
          - Criadas e identificadas pelo o modificador abstract
          - Podem conter métodos comuns e métodos/propriedades abstratos(modificador abstract)
          - Não podem ser instanciadas
          - Podem ser herdados; quem herda tem que implementar os métodos/propriedades abstratos
          - Podem ter um construtor;
        - Interfaces
          - Criadas e identificadas pelo o modificador interface
          - Estabelecem um contrato com quem for implementar a interface
          - Podem conter somente métodos/propriedades que não tenham implementação
          - Podem ser instanciadas
          - Podem ser herdadas, quem herda tem que implementar o contrato definido
          - Não possuem um construtor
     - Polimorfismo
       - Polimorfismo significa várias formas
       - Ocorre quando há um relacionamento de Herança entre as classes(É um)
       - O polimorfismo se manifesta, permitindo que classes forneçam diferentes implementações de métodos que são chamados com o mesmo nome.
       - Polimorfismo é o principio pelo qual duas ou mais classes derivadas de uma mesma superclasse podem invocar que tem a mesma assinatura mas comportamentos distintos,          que são especializados para cada classe derivada, usando para tanto um referencia a um objeto do tipo superclasse.
       - Polimorfismo em tempo de execução(Overrinding/Sobreescrita)
         - Usa herança e métodos virtuais
         - Sobrescreve métodos virtuais alterando comportamento da classe derivada
       - Polimorfismo em tempo de compilação(Overloading/Sobrecarga)
         - Utiliza a sobrecarga de métodos e operadores
         - Realiza a tarefa com distintos parâmetros de entrada
      - C# 8 - Default members interface
        - Permite adicionar membros as interfaces e fornecer uma implementação padrão para esses membros.
        - Adicionar um novo método padrão a uma interface existente sem quebrar o código das classes que implementam a interface
        - É opcional para os implementadores substituir ou não o método.

### Principios SOLID - Conceitos e prática
 - Code Smell
   - Code Smell
     - O termo Code Smell(código que cheira) é aplicado quando o código fonte de qualquer programa indica algum problema
     - O code smell indica que o projeto de software não foi bem feito e que vai apresentar uma alta taxa de manutenção com riscos de apresentar bugs catastróficos no              futuro.
   - Rigidez
     - Um código rígido é aquele que quando alterado vai exigir mudanças em outras partes do código e essas mudanças quando feitas vão se propagar por todo o  código.
   - Fragilidade
     -  Um código frágil é aquele que quando alterado quebra o código de maneiras inesperadas, em áreas que não parecem estar relacionadas a que voce esta                           trabalhando.
     -  Voce faz um alteração em um modulo e outro modulo deixa de funcionar
   - Imobilidade
     - Um código imóvel não permite ser reutilizado em outras partes do projeto ou mesmo em outros projetos.
   - Redundante
     - É um código que se repete ao longo do projeto aparecendo em mais de um lugar causando dificuldade e na correção de falhas
   - **Confuso**
     - **É um código extenso e difícil de ser entendido por quem lê o código.**
     - Se voce não compreende o código como vai poder altera-lo se precisar ?
     - **Se você precisa de comentários no código para entender o que ele faz então o seu código é opaco e cheira mal**
- Clean Code
  - Clean Code é uma filosofia de desenvolvimento cujo principal objetivo é aplicar técnicas simples que visam facilitar a escrita e leitura de um código.
  - "Aprender a criar códigos limpos é uma tarefa árdua e requer mais do que simples conhecimento dos principais padrões. Você tem que suar a camisa;praticar sozinho e ver      que cometeu erros;"
  - O Clean Code nos da uma serie de boas praticas que podemos aplicar no nosso código para torna-lo limpo e objetivo.
  - Aplicando boas praticas: Clean Code
    - Nomenclatura: Adote um padrão
    - Use Nomes significativos
    - Organize o código
    - use métodos pequenos
    - Seja comedido nos comentários
    - Documente somente o necessário
    - Evite números mágicos
    - Realize o tratamento de erros
- DRY - Dont Repeat Yourself
  - Cada parte do conhecimento deve ter uma representação unica, inequívoca e definitiva dentro de um sistema.
  - O que podemos entender por conhecimento ?
    - Uma funcionalidade precisa no domínio de negócios de seu aplicativo
    - Um algoritmo
  - O conceito de DRY não esta apenas relacionado com a ideia de 'não duplicar codigo'
  - A ideia por trás do DRY é muito mais ampla
  - Logica de Remessa
    - Representada uma funcionalidade no domínio do negócio.
    - Se voce espalhar a logica de remessa de um pedido pela aplicação quando voce tiver que alterar o seu comportamento vai ter que fazer isso em mais de um lugar.               (Violação do DRY)
  - Forma correta:
    - Criar uma representação unica do seu conhecimento.
    - Colocar a logica para enviar a remessa em um só lugar e depois usar a representação desse conhecimento em qualquer lugar que voce precisar.
  - O principio DRY tem a ver duplicação da logica do conhecimento e não simplesmente com a duplicação de código.
  - Possuir a logica do conhecimento em um único lugar para facilitar a manutenção.
- Princípios SOLID - Apresentação
  - OS princípios SOLID representam cinco princípios de boas praticas da programação orientada a objetos que ajudam a escrever códigos mais robustos, com baixo acoplamento,     fáceis de estender, testar, reutilizar e de manter.
  - A palavra SOLID é um acrônimo, criado por Michael Feathers
  - Esses princípios foram identificados por Robert Cecil Martin (Uncle Bob)
  - Acrônimo: SOLID
    - SRP: Single Responsability Principle
      - Princípio da Responsabilidade Única: uma classe deve ter um, e somente um, motivo para mudar.
    - OCP: Open/Closed Principle
      - Principio do Aberto/Fechado: Você deve ser capaz de estender um comportamento de uma classe sem a necessidade de modificá-lo
    - LSP: Liskov Substitution Principle
      - Princípio da substituição de Liskov - As classes derivadas devem ser substituíveis por suas classes bases.
    - ISP: Interface Segregation Principle
      - Princípio da segregação de interfaces - Muitas interfaces específicas são melhores do que uma interface única geral.
    - DIP: Dependency Inversion Principle
      - Princípio da inversão de dependência - Dependa de abstrações e não de implementações.
